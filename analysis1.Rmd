---
title: "Excess death in the US by age"
author: "Dan Weinberger"
date: "10/29/2020"
output:
  html_document:
    df_print: paged
    html_document: null
    toc: yes
    toc_depth: 2
    toc_float: yes
  word_document:
    toc: yes
    toc_depth: '2'
  pdf_document: 
    keep_tex:  true
params:
  agg.level: 'state'
  n.days.filter: 20
  web.version: FALSE
  extrap.date: '2020-01-26'
  count.start.date: '2020-03-01'
  end.data.date: '2020-09-05'
---

```{r, include = F}
knitr::opts_chunk$set(
  collapse = TRUE,
  echo=F,
  warning=FALSE, 
  message=FALSE,
  comment = "#>",
  dev=c('png','pdf'),
  fig.path='./figures/',
  gganimate = list(
    nframes = 50)
)

extrap.date <-  as.Date(params$extrap.date)
count.start.date <- as.Date(params$count.start.date)
end.data.date <- as.Date(params$end.data.date)

state.name2 <- c(state.name, 'District of Columbia','Puerto Rico', 'United States', 'New York City')
state.abb2 <- c(state.abb, 'DC','PR','US','NYC')


last.date.format <- 
  format(end.data.date, '%b %d, %Y')
```

```{r setup}
library(ExcessILI)
library(readxl)
library(cdcfluview)
library(reshape2)
library(ggplot2)
library(lubridate)
library(RColorBrewer)
library(plotly)
library(MMWRweek)
library(readr)
library(rjson)
library(htmlTable)
library(RSocrata)
library(pdftools)
library(readr)
library(abind)
library(gsubfn)
library(dplyr)
library(RCurl)
library(tidyverse)
library(gifski)
library(gganimate)
library(shiny)
library(rjags)
#library(jsonlite)
set.seed(123)

```

```{r archivfunc}
# Using ExcessILI's data archiving functions, returns the most recent copy of
# output obtained by running a function or formula \code{f}, unless this 
# copy doesn't exist or is older (by modification time) than \code{maxage}.
# In that case, \code{f} is run and the output is archived into the folder
# Data/'storeName' as an RDS file, using the function ExcessILI::storeRDS.
#
# @param storeName A string. The name of the folder to store output in
# @param f A function or formula taking no arguments. Formulas are coerced to
#   functions.
# @param maxage How old can any existing archived file be before \code{f} is 
#   called again?
runIfExpired <- function(storeName, f, maxage=hours(99999999999999)) {
  basepath <- "Data/"
  mostRecent <- mostRecentTimestamp(storeName, basepath=basepath)
  f <- rlang::as_function(f)
  
  runAndArchive <- function() {
    data <- f()
    storeRDS(data, storeName, basepath)
    data
  }
    
  if (is.na(mostRecent)) 
    return(runAndArchive())

  if (mostRecent %--% now() < maxage)
    return(retrieveRDS(storeName, basepath))

  runAndArchive()
}
```

```{r, eval=F}
if (!require("devtools")) {
  install.packages("devtools")
}
devtools::install_github("weinbergerlab/ExcessILI")
#Test12343
```

## Download and archive the latest version of the data from NCHS
set maxage to a small number (e.g. 24, for 24 hours) if you want to to download a recent copy of the data; otherwise it will use the most recent copy on disk in the Data/nchs_age_state folder
```{r}
nchs.age.state <- runIfExpired('nchs_age_state', maxage=999,
 ~read.csv("https://data.cdc.gov/api/views/y5bj-9g5w/rows.csv?accessType=DOWNLOAD") 
 )

```

```{r}
age1 <- nchs.age.state
age1 <- age1[ age1$Type=='Unweighted' & age1$Suppress =='',]
age1 <- age1[,c('Week.Ending.Date', 'Age.Group','Number.of.Deaths', 'State.Abbreviation' )]
age1$Week.Ending.Date <- as.Date(age1$Week.Ending.Date, '%m/%d/%Y')


#Cut off last 2 months of data--incomplete reporting
max.date <- max(age1$Week.Ending.Date)
age1 <- age1[age1$Week.Ending.Date<= (max.date-60),]

names(age1) <-c('week_end','age_group','all_cause','state')
age1$one <-1

age1$age_group[age1$age_group=="Under 25 years"] <- '0-25 years'
```

Filter data by sparsity. Some subgroups are suppressed
**CAUTION** many strata, particularly from smaller states get filtered out here, so need to be careful about aggregate values.

For now, only keep states that have all 6 age categories
```{r}
age.spl <- split(age1, paste0(age1$age_group, age1$state))
n.obs.weeks <- sapply(age.spl, nrow)
max.obs.weeks <- max(n.obs.weeks, na.rm=T)

age.spl <- age.spl[n.obs.weeks==max.obs.weeks]

age2 <- bind_rows(age.spl)

age2.spl <- split(age2, age2$state)
n.ages.state <- sapply(age2.spl, nrow)/max.obs.weeks
age2.spl <- age2.spl[n.ages.state==6]

ag3 <- bind_rows(age2.spl)
saveRDS(ag3,'./Data/cleaned_file.rds')
```




## run the model
```{r}

mod1 <- excessCases(ag3, 
             statevar = "state",
             agevar='age_group',
             datevar = "week_end", 
             use.syndromes = c("all_cause"),
            extrapolation.date = as.Date("2020-03-01"), 
            sum.dates = as.Date("2020-03-01"),
            denom.var = "one",
            extend.epiyear =TRUE,
            time.res='week',
            model.type='poisson') 

#saveRDS(mod1,'results1.rds')

```

## Interactive dashboard plot
```{r}


app1 <-dashboardPlot(mod1)
print(app1)
```

## Heatmap type dashboard
```{r}
source('app.R')
shiny::shinyApp(ui, server)

```


```{r}
 excess_output=mod1
 statevar = "state"
 agevar='age_group'
 datevar = "date"
 outcome='all_cause'
 yaxis=statevar
 facet=agevar
  library(dplyr)
    df_y <- excess_output %>% pluck(outcome) %>% map(~(transpose(.x) %>% 
        map(~(.x %>% bind_rows())) %>% .[c(datevar, "y")] %>% 
        map(~(.x %>% gather(statevar, y))) %>% bind_cols() %>% 
        set_names(c(statevar, datevar, "rm", "y")) %>% 
        dplyr::select(-rm))) %>% bind_rows(.id = agevar)
    
    df_pred <- excess_output %>% pluck(outcome) %>% map(~(transpose(.x) %>% 
        map(~(.x %>% bind_rows())) %>% .[c(datevar, "pred")] %>% 
        map(~(.x %>% gather(statevar, pred))) %>% bind_cols() %>% 
        set_names(c(statevar, datevar, "rm", "pred")) %>% 
        dplyr::select(-rm))) %>% bind_rows(.id = agevar)
    df_oe <- df_y %>% left_join(df_pred, by = c(agevar, statevar, 
        datevar)) %>% mutate(oe = y/pred, year = year(get(datevar)), 
        week = week(get(datevar)), oe_fac = cut(oe, breaks = c(-Inf, 
            0.5, 1, 1.25, 1.5, 1.75, 2, 2.5, 3, 3.5, 4, 6, 8, 
            10, Inf), labels = c("0.5", "1.0", "1.25", 
            "1.5", "1.75", "2.0", "2.5", 
            "3.0", "3.5", "4.0", "6.0", 
            "8.0", "10.0", ">10.0")), oe_fac_rev = factor(oe_fac, 
            levels = rev(levels(oe_fac))))
    dates <- as.Date(unique(df_oe[[datevar]]))
    states <- unique(df_oe[[statevar]])
    age_groups <- unique(df_oe[[agevar]])
    last.date <- max(dates)
    last.date.format <- format(last.date, "%b %d, %Y")

    ui <- fluidPage(shiny::titlePanel(paste0("Data through ", 
        last.date.format)), shiny::sidebarLayout(shiny::sidebarPanel(shiny::selectInput(input = "set.states", 
        label = "State:", choice = states, selected = c("NY"), 
        multiple = T), shiny::selectInput(input = "set.ages", 
        label = "Age group:", choice = age_groups, selected = c("18 and under", 
            "19-64", "65 and over"), multiple = T), 
        shiny::sliderInput(input = "display.dates", label = "Earliest date to display", 
            min = min(dates), max = dates[length(dates) - 2], 
            step = 7, value = dates[length(dates) - round(length(dates)/5)])), 
        shiny::mainPanel(shiny::plotOutput("plot"))))
    server <- function(input, output) {
        library(ggplot2)
        dates_states_ages_sel <- reactive({
            req(input$display.dates, input$set.states, input$set.ages)
            df_oe %>% filter(get(datevar) >= input$display.dates & 
                get(statevar) %in% c(input$set.states) & get(agevar) %in% 
                c(input$set.ages))
        })
        output$plot = renderPlot({
            ggplot(data = dates_states_ages_sel(), aes(x = factor(get(datevar)), 
                y = get(yaxis))) + geom_raster(aes(fill = oe_fac_rev), 
                interpolate = F) + scale_fill_manual(values = c(`>10.0` = "#5c0900", 
                `10.0` = "#850d00", `8.0` = "#a31000", 
                `6.0` = "#c21300", `4.0` = "#eb1800", 
                `3.5` = "#ff3e29", `3.0` = "#ff7014", 
                `2.5` = "#ff9049", `2.0` = "#ffaf35", 
                `1.75` = "#ffd230", `1.5` = "#a3a3cc", 
                `1.25` = "#b7b7d7", `1.0` = "#cacae2", 
                `0.5` = "#dbdbeb")) + xlab("Time") + 
                labs(fill = "O/E Ratio") + scale_x_discrete(expand = c(0, 
                0)) + scale_y_discrete(expand = c(0, 0)) + facet_grid(get(facet) ~ 
                .) + theme_bw() + theme(axis.title.y = element_blank(), 
                axis.text.x = element_text(size = 7, vjust = 1, 
                  hjust = 0, angle = 90))
        })
    }
    shiny::shinyApp(ui, server)
}
```




Extract output as arrays
 Can use this to calculate all sorts of custom things, like excess aggregated over different time periods. Some of the outputs contain draws from a Monte Carlo simulation, which can be used for propagating errors. For example, below we have sum.obs.ac gives the total deaths during the evaluation periods, and sum.pred.iter gives 10,000 values of the sum predicted value. These could be combined across strata
```{r}
ds <- mod1
dates1 <-
  ds[[1]][[1]][[1]]$date
  
sum.obs.ac <-
    excessExtract(ds = ds,
                syndrome = 'all_cause',
                extract.quantity = "sum.obs")

sum.pred.iter <-
    excessExtract(ds = ds,
                syndrome = 'all_cause',
                extract.quantity = "sum.pred.iter")

```

## Sum across age groups, by state
Print the 95% CIs for the RR (overall observed/expected deaths by state)
```{r}

pred.state.iter <- apply(sum.pred.iter,c(1,2), sum)

sum.obs.ac.state <- apply(sum.obs.ac, c(2), sum)

RR.state <- apply(pred.state.iter,1, function(x) sum.obs.ac.state/x)
RR.state.q <- round(t(apply(RR.state,1,quantile, probs=c(0.025,0.5,0.975))),2)
RR.state.q

```



```{r}
excess_output = mod1
            statevar = "state"
             agevar='age_group'
             datevar = "date" 
             outcome='all_cause' 
             yaxis=statevar
             facet=agevar


  df_y <- 
    excess_output  %>% 
    pluck(outcome) %>% 
    map(~(
      transpose(.x) %>% 
        map(~(.x %>% bind_rows())) %>% .[c(datevar, "y")] %>% 
        map(~(.x %>% gather(statevar, y))) %>% 
        bind_cols()  %>% 
        set_names(c(statevar, datevar, "rm", "y")) %>% 
        dplyr::select(-rm)
    )) %>% 
    bind_rows(.id = agevar) 
  
  
```
## Multilevel model

JAGS
```{r}
ag3 <- readRDS('./Data/cleaned_file.rds')

source('./R/jags_mod1.R')

ag3.m <- reshape2::melt(ag3, id.vars=c('age_group','state','week_end'))
ag3.c <- acast(ag3.m[ag3.m$variable=='all_cause',], age_group ~ state ~week_end)

time <- 1:dim(ag3.c)[3]
sin1 <- sin(2*pi*time/52.1775)
sin2 <- sin(2*pi*time*2/52.1775)
sin3 <- sin(2*pi*time*3/52.1775)

cos1 <- cos(2*pi*time/52.1775)
cos2 <- cos(2*pi*time*2/52.1775)
cos3 <- cos(2*pi*time*3/52.1775)

dataset <- list('y' = ag3.c, 
                'n.date'=dim(ag3.c)[3],
                'n.age'=dim(ag3.c)[1],
                "n.state"=dim(ag3.c)[2],
                'sin1'=sin1,
                'sin2'=sin2,
                'sin3'=sin3,
                'cos1'=cos1,
                'cos2'=cos2,
                'cos3'=cos3,
                'time'=time
                )

jags_post <- jags.model(textConnection(model_string_non_nested), data = dataset,
                    n.chains = 3)
 update(jags_post, 
         n.iter=75000)
  rsv_resp <- coda.samples(jags_post, variable.names=c("rd2","lambda","rd1","phi", "rd0","epi","delta"),
                      thin = 20,n.iter = 60000)

```

INLA
```{r}
library(INLA)
library(lme4)

ag3 <- readRDS('./Data/cleaned_file.rds')

ag3$time <- 1:length(unique(ag3$week_end))
ag3$sin1 <- sin(2*pi*ag3$time/52.1775)
ag3$sin2 <- sin(2*pi*ag3$time*2/52.1775)
ag3$sin3 <- sin(2*pi*ag3$time*3/52.1775)

ag3$cos1 <- cos(2*pi*ag3$time/52.1775)
ag3$cos2 <- cos(2*pi*ag3$time*2/52.1775)
ag3$cos3 <- cos(2*pi*ag3$time*3/52.1775)
 
ag3$age_group <- as.factor(ag3$age_group)
ag3$state <- as.factor(ag3$state)

#mod.inla <- inla(all_cause ~  , family='poisson')

ag3$all_cause_pre <- ag3$all_cause

ag3$all_cause_pre[ag3$week_end >= '2020-03-01'] <- NA
ag3$time_scale <- as.vector(scale(ag3$time))

ag3.pre <- ag3[ag3$week_end < '2020-03-01',] %>%
  group_by(state,age_group) %>%
  summarize( log.ave.case = log(mean(all_cause)  ))
  
ag3 <- merge( ag3, ag3.pre, by=c('state','age_group'))
# mod.lme1 <- lme4::glmer(all_cause_pre ~ 1 + time_scale + sin1+sin2 +sin3 +cos1 +cos2 +cos3  + (1|age_group) + 
#                           (1|state) + 
#                           (0+sin1 +cos1|age_group) +
#                           (0+sin1 +cos1|state) +
#                           (0+sin2 +cos2|age_group) +
#                           (0+sin2 +cos2|state) +   
#                           (0+sin3 +cos3|age_group) +
#                           (0+sin3 +cos3|state) +
#                           (0+time_scale|age_group) +
#                           (0+time_scale|state) 
#                         ,   family='poisson', data=ag3)
# 
# mod.lme1 <- lme4::glmer(all_cause_pre ~ 1 + time_scale + sin1+sin2 +sin3 +cos1 +cos2 +cos3  + 
#           (1 + sin1 +cos1 + sin2 +cos2 + sin3 +cos3 + time_scale||age_group) 
#                        ,   family='poisson', data=ag3)
```

Simple GLM
```{r}
mod.glm1 <- glm(all_cause_pre ~ 
                1 + time_scale + 
                sin1 + sin2 + sin3 + cos1 +cos2+ cos3 
                offset = log.ave.case,
                family='poisson', data=ag3)
summary(mod.glm1)
```

Simple INLA
```{r}
mod.inla1 <- inla(all_cause_pre ~ 
                1 + time_scale + 
                sin1 + sin2 + sin3 + cos1 +cos2+ cos3  ,
                offset = log.ave.case,
                family='poisson', data=ag3)
summary(mod.inla1)
```

```{r}
ag3$state_ag_combo <- as.factor(paste(ag3$state, ag3$age_group))
ag3$state_ag_combo2 <- ag3$state_ag_combo
ag3$state_ag_combo3 <- ag3$state_ag_combo

ag3$age_group2 <- ag3$age_group
ag3$age_group3 <- ag3$age_group

ag3$state2 <- ag3$state
ag3$state3 <- ag3$state

mod.inla2 <- inla(all_cause_pre ~ 
                1 + time_scale + 
                sin1 + sin2 + sin3 + cos1 +cos2+ cos3 +
                 f(age_group, time_scale ,model='iid') +
                 f(state, time_scale,model='iid') +
                  f(state_ag_combo, time_scale,model='iid') +
                  
                f(age_group2, sin1 ,model='iid') +
                 f(state2, sin1,model='iid') +
                  f(state_ag_combo2, sin1,model='iid') +
                  
                  f(age_group3, cos1 ,model='iid') +
                 f(state3, cos1,model='iid') +
                  f(state_ag_combo3, cos1,model='iid') 
                    ,
                                offset = log.ave.case,
                family='poisson', data=ag3,
                control.compute=list(config = TRUE))
summary(mod.inla2)

pred.sample.list <- inla.posterior.sample(n=500, mod.inla2, seed=123)

post.labels<-dimnames(pred.sample.list[[1]]$latent)[[1]]

posterior.samples<- sapply(pred.sample.list, '[[', 'latent')

preds.select<-grep('Predictor',post.labels )

posterior.preds<-exp(posterior.samples[preds.select,]) #lambda

preds.summary <- apply(posterior.preds,1, quantile, probs=c(0.025,0.5,0.975))

ag3.preds <- cbind.data.frame(preds.summary,ag3)

```


Simple RSTANARM model
```{r}


library(rstanarm)
#Vanilla harmonic regression runs in 2 minutes)
mod.stan.glm1 <- rstanarm::stan_glm(all_cause_pre ~ 
                1 + time_scale + 
                sin1+sin2 +sin3 +cos1 +cos2 +cos3, # + 
                #age_group + 
                #  state ,
                offset = log.ave.case,
                family='poisson', data=ag3,cores=3,chains=3, QR=T,
                prior_intercept = normal(0,5) ,
                 prior = normal(0,1),
                      seed = 12345)
pplot<-plot(mod.stan.glm1, "areas", prob = 0.95, prob_outer = 1)
pplot+ geom_vline(xintercept = 0)              
```

Try with horseshoe prior and all the interactions

```{r}
p0 <- 10 # prior guess for the number of relevant variables
mod.mat1 <- model.matrix(~1 +  
                state*age_group*(time_scale+ sin1+sin2 +sin3 +cos1 +cos2 +cos3), data=ag3)
n <- nrow(ag3)
p <- ncol(mod.mat1)
tau0 <- p0/(p-p0) * 1/sqrt(n)
hs_prior <- hs(df=1, global_df=1, global_scale=tau0)

mod.stan.glm2 <- rstanarm::stan_glm(all_cause_pre ~ 
                1 +  
                state*age_group*(time_scale+ sin1+sin2 +sin3 +cos1 +cos2 +cos3), 
                offset = log.ave.case,
                family='poisson', data=ag3,cores=3,chains=3, QR=T,
                prior_intercept = normal(0,1) ,
                 prior = hs_prior,
                      seed = 12345)
```


Add random slope for the harmonics
```{r}
mod.stan.glmer1 <- rstanarm::stan_glmer(all_cause_pre ~ 
                1 + time_scale + 
                sin1+sin2 +sin3 +cos1 +cos2 +cos3+
                  (0+sin1|age_group) , 
                offset = log.ave.case,
                family='poisson', data=ag3,cores=3,chains=3, QR=T,
                prior_intercept = normal(0,5) ,
                 prior = normal(0,1),
                      seed = 12345)
pplot<-plot(mod.stan.glmer1, "areas", prob = 0.95, prob_outer = 1)
pplot+ geom_vline(xintercept = 0)
```


